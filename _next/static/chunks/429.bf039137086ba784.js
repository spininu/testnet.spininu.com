"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[429],{94429:function(t,e,i){i.r(e),i.d(e,{MetamaskAdapter:function(){return h}});var s=i(4942),a=i(92003),n=i.n(a),r=i(41436);class h extends r.J5{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),(0,s.Z)(this,"adapterNamespace",r.yk.EIP155),(0,s.Z)(this,"currentChainNamespace",r.EN.EIP155),(0,s.Z)(this,"type",r.hN.EXTERNAL),(0,s.Z)(this,"name",r.rW.METAMASK),(0,s.Z)(this,"status",r.MP.NOT_READY),(0,s.Z)(this,"rehydrated",!1),(0,s.Z)(this,"metamaskProvider",null),this.chainConfig=t.chainConfig||null}get provider(){return this.status===r.MP.CONNECTED&&this.metamaskProvider?this.metamaskProvider:null}set provider(t){throw new Error("Not implemented")}async init(t){if(super.checkInitializationRequirements(),this.metamaskProvider=await n()({mustBeMetaMask:!0}),!this.metamaskProvider)throw r.Ty.notInstalled("Metamask extension is not installed");this.status=r.MP.READY,this.emit(r.n2.READY,r.rW.METAMASK);try{r.cM.debug("initializing metamask adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(e){this.emit(r.n2.ERRORED,e)}}setAdapterSettings(t){}async connect(){if(super.checkConnectionRequirements(),this.chainConfig||(this.chainConfig=(0,r.h2)(r.EN.EIP155,1)),this.status=r.MP.CONNECTING,this.emit(r.n2.CONNECTING,{adapter:r.rW.METAMASK}),!this.metamaskProvider)throw r.RM.notConnectedError("Not able to connect with metamask");try{await this.metamaskProvider.request({method:"eth_requestAccounts"});const{chainId:t}=this.metamaskProvider;if(t!==this.chainConfig.chainId&&await this.switchChain(this.chainConfig),this.status=r.MP.CONNECTED,!this.provider)throw r.RM.notConnectedError("Failed to connect with provider");return this.provider.once("disconnect",(()=>{this.disconnect()})),this.emit(r.n2.CONNECTED,{adapter:r.rW.METAMASK,reconnected:this.rehydrated}),this.provider}catch(t){throw this.status=r.MP.READY,this.rehydrated=!1,this.emit(r.n2.ERRORED,t),r.RM.connectionError("Failed to login with metamask wallet")}}async disconnect(){var t;let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==r.MP.CONNECTED)throw r.RM.disconnectionError("Not connected with wallet");null===(t=this.provider)||void 0===t||t.removeAllListeners(),e.cleanup?(this.status=r.MP.NOT_READY,this.metamaskProvider=null):this.status=r.MP.READY,this.rehydrated=!1,this.emit(r.n2.DISCONNECTED)}async getUserInfo(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async switchChain(t){if(!this.metamaskProvider)throw r.RM.notConnectedError("Not connected with wallet");try{await this.metamaskProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:t.chainId}]})}catch(e){if(4902!==e.code)throw e;await this.metamaskProvider.request({method:"wallet_addEthereumChain",params:[{chainId:t.chainId,chainName:t.displayName,rpcUrls:[t.rpcTarget]}]})}}}}}]);